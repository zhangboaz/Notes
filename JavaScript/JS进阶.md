## 作用域
### 局部作用域
1. 函数作用域
    函数内部声明的变量只能在函数内部被访问，外部无法直接访问
    * 函数内部声明的变量，在函数外部无法被访问
    * 函数的参数也是函数内部的局部变量
    * 不同函数内部声明的变量无法互相访问
    * 函数执行完毕后，函数内部的变量实际被清空了
2. 块作用域
    在JavaScript中使用{}包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法直接访问
    * let声明的变量会产生块作用域，var不会产生块作用域
    * const声明的常量也会产生块作用域
    * 不同代码块之间的变量无法直接访问
    * 推荐使用let或const
### 全局作用域
* script标签和.js文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问
* 全局作用域中声明的变量，任何其他作用域都可以被访问
* 为window对象动态添加的属性默认也是全局的，不推荐
* 函数中未使用任何关键字声明的变量为全局变量，不推荐
* 尽可能少的声明全局变量，防止全局变量污染
### 作用域链
* 作用域链本质上是最底层的变量查找机制
* 在函数执行时，会优先查找当前函数作用域中查找变量
* 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域
* 嵌套关系的作用域串联起来形成了作用域链
* 相同作用域链中按照从小到大的规则查找变量
* 子作用域能够访问父作用域，父级作用域无法访问子级作用域
### JS垃圾回收机制 GC
* JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收
#### 内存的生命周期
JS环境中分配的内存，一般有如下生命周期
1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. 内存使用：即读写内存，也就是使用变量，函数等
3. 内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存
* 全局变量一般不会回收（关闭页面回收）
* 一般情况下局部变量的值，不用了，会被自动回收掉
##### 内存泄漏
* 程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏
#### 算法说明
##### 堆栈空间分配说明
1. 栈（操作系统）：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型都放在栈里面
2. 堆（操作系统）：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放在堆里面
##### 引用计数
* IE采用的引用计数算法，定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象
* 算法
  1. 跟踪记录被引用的次数
  2. 如果被引用了一次，那么就记录次数 1，多次引用会累加 ++
  3. 如果减少一个引用就减 1 --
  4. 如果引用次数是0，则释放内存
* 但是它有一个致命的问题：嵌套引用（循环引用）
  如果两个对象相互引用，尽管他们已经不再使用，垃圾回收机制不会进行回收，导致内存泄漏
##### 标记清除法
* 核心
  1. 标记清除算法将“不再使用的对象”定义为“无法达到的对象”
  2. 就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的
  3. 那些无法由根部出发触及的对象被标记为不再使用，稍后进行回收
### 闭包
#### 概念
* 一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域
* 闭包 = 内层函数 + 外层函数的变量
#### 作用
* 封闭数据，提供操作，外部也可以访问函数内部的变量
#### 基本格式
```javascript
function outer() {
    let i = 1
    return function () {
        console.log(i)
    }
}
const fun = outer()
fun()
```
#### 应用
* 实现数据的私有
* 例如统计函数调用次数
  ```javascript
  function outer() {
  let i = 1
  function fn() {
    i++
    console.log(i)
  }
  }
  const fun = outer()
  fun()
  ```
* 闭包会引起内存泄漏
### 变量提升
* 把所有var声明的变量提升到当前作用域的最前面
* 只提升声明，不提升赋值
## 函数进阶
### 函数提升
* 会把所有函数声明提升到当前作用域的最前面
* 只提升函数声明，不提升函数调用
### 函数参数
#### 动态参数
* `arguments`是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参
#### 剩余参数
* `...数组名` 剩余参数允许我们将一个不定数量的参数表示成一个数组
### 展开运算符
* 展开运算符`...`将一个数组进行展开
* 应用场景：求数组最大值或最小值、合并数组等
  ```javascript
  let arr1 = [1, 2, 3]
  let arr2 = [4, 5, 6]
  console.log(...arr1) // 1 2 3
  console.log(Math.max(...arr1)) //求最大值
  console.log(Math.min(...arr2)) // 求最小值
  let arr3 = [...arr1, ...arr2] //合并两个数组
  ```
### 箭头函数
#### 目的
引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁
#### 使用场景
箭头函数更适用于那些需要匿名函数的地方
#### 基本语法
```javascript
// 普通函数
const fn = function(){
    console.log(1)
}
fn()
// 箭头函数
const fn = () => {
    console.log(1)
}
fn()
```
* 只有一个形参的时候，可以省略小括号
  ```javascript
  const fn = x => {
    console.log(x)
  }
  ```
* 只有一行代码的时候，可以省略大括号
  ```javascript
  const fn = x => console.log(x)
  ```
* 只有一行代码可以省略`return`
  ```javascript
  const fn = x => {
    return x + x
  }
  const fn = x => return x + x
  ```
* 箭头函数可以直接返回一个对象：加括号的函数体返回对象字面量表达式
  ```javascript
  const fn = uname => ({uname: uname})
  ```
#### 箭头函数参数
* 箭头函数里面没有`arguments`动态参数，但是有`...arr`剩余参数
#### 箭头函数`this`
箭头函数不会创建自己的`this`，它只会从自己的作用域链的上一层沿用`this`
## 解构赋值
### 数组解构
数组解构是将数组的单元值快速批量赋值给一系列变量的简介语法
#### 基本语法
1. 赋值运算符 = ，左侧的[]用于批量声明变量，右侧数组的单元值将被赋值给左边的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作
```javascript
// 普通数组
const arr = [1, 2, 3]
// 批量声明变量 a b c
// 同时将数组单元值 1 2 3 依次赋值给变量 a bc
const [a, b, c] = arr
console.log(a) // 1 
console.log(b) // 2
console.log(c) // 3
```
### 对象解构
对象解构是将对象属性和方法快速批量赋值给一系列变量的简介语法
#### 基本语法
1. 赋值运算符 = ，左侧的[]用于批量声明变量，右侧对象的属性值将被赋值给左边的变量
2. 对象属性的值将被赋值给与属性名相同的变量
3. 注意解构的变量名不要和外面的变量名冲突否则报错
4. 对象中找不到与变量名一致的属性是变量值为`underfined`
## 遍历数组forEach方法（重点）
遍历数组的每个元素
#### 语法
```javascript
被遍历的数组.forEach(function (当前数组元素, 当前元素索引号){
    // 函数体
})
```